using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;

#pragma warning disable RS1024 // Symbols should be compared for equality

namespace JasperFx.Events.SourceGenerator;

internal static class EvolverCodeEmitter
{
    public static string EmitPartialProjection(CandidateInfo info)
    {
        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();

        var ns = info.ClassSymbol.ContainingNamespace;
        if (!ns.IsGlobalNamespace)
        {
            sb.AppendLine($"namespace {ns.ToDisplayString()};");
            sb.AppendLine();
        }

        var className = info.ClassSymbol.Name;

        // Include type parameters if the class is generic
        var typeParams = "";
        if (info.ClassSymbol.TypeParameters.Length > 0)
        {
            typeParams = "<" + string.Join(", ", info.ClassSymbol.TypeParameters.Select(t => t.Name)) + ">";
        }

        sb.AppendLine($"partial class {className}{typeParams}");
        sb.AppendLine("{");

        // Generate constructor that calls IncludeType<T>() for every event type
        EmitConstructorWithIncludeTypes(sb, info, className);
        sb.AppendLine();

        if (info.HasShouldDelete)
        {
            EmitDetermineActionAsyncOverride(sb, info);
        }
        else if (info.HasAnyAsync)
        {
            EmitEvolveAsyncOverride(sb, info);
        }
        else
        {
            EmitEvolveOverride(sb, info);
        }

        sb.AppendLine("}");
        return sb.ToString();
    }

    private static void EmitConstructorWithIncludeTypes(StringBuilder sb, CandidateInfo info, string className)
    {
        var eventTypes = info.Methods.Select(m => m.EventType.ToDisplayString()).Distinct().ToList();
        if (eventTypes.Count == 0) return;

        // Skip if the class already has an explicit parameterless constructor
        if (info.HasExistingParameterlessConstructor) return;

        sb.AppendLine($"    public {className}()");
        sb.AppendLine("    {");
        foreach (var eventType in eventTypes)
        {
            sb.AppendLine($"        IncludeType<{eventType}>();");
        }
        sb.AppendLine("    }");
    }

    public static string EmitSelfAggregatingEvolver(CandidateInfo info)
    {
        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();

        var aggregateFullName = info.AggregateType!.ToDisplayString();
        var idFullName = info.IdentityType!.ToDisplayString();
        var evolverName = info.ClassSymbol.Name + "Evolver";

        // Assembly attributes must precede namespace declarations
        sb.AppendLine($"[assembly: global::JasperFx.Events.Aggregation.GeneratedEvolver(typeof({aggregateFullName}), typeof({GetFullyQualifiedEvolverName(info, evolverName)}))]");
        sb.AppendLine();

        var ns = info.ClassSymbol.ContainingNamespace;
        if (!ns.IsGlobalNamespace)
        {
            sb.AppendLine($"namespace {ns.ToDisplayString()};");
            sb.AppendLine();
        }

        if (info.HasShouldDelete)
        {
            sb.AppendLine($"internal sealed class {evolverName} : global::JasperFx.Events.Aggregation.IGeneratedSyncDetermineAction<{aggregateFullName}, {idFullName}>");
            sb.AppendLine("{");
            EmitEventTypesProperty(sb, info);
            sb.AppendLine();
            EmitSelfAggregatingDetermineAction(sb, info, aggregateFullName, idFullName);
        }
        else
        {
            sb.AppendLine($"internal sealed class {evolverName} : global::JasperFx.Events.Aggregation.IGeneratedSyncEvolver<{aggregateFullName}, {idFullName}>");
            sb.AppendLine("{");
            EmitEventTypesProperty(sb, info);
            sb.AppendLine();
            EmitSelfAggregatingEvolve(sb, info, aggregateFullName, idFullName);
        }

        sb.AppendLine("}");
        return sb.ToString();
    }

    private static string GetFullyQualifiedEvolverName(CandidateInfo info, string evolverName)
    {
        var ns = info.ClassSymbol.ContainingNamespace;
        if (!ns.IsGlobalNamespace)
            return $"{ns.ToDisplayString()}.{evolverName}";
        return evolverName;
    }

    private static void EmitEventTypesProperty(StringBuilder sb, CandidateInfo info)
    {
        var eventTypes = info.Methods.Select(m => m.EventType.ToDisplayString()).Distinct().ToList();
        sb.Append("    public global::System.Type[] EventTypes => [");
        sb.Append(string.Join(", ", eventTypes.Select(t => $"typeof({t})")));
        sb.AppendLine("];");
    }

    // --- Partial projection: Evolve (all sync, no ShouldDelete) ---

    private static void EmitEvolveOverride(StringBuilder sb, CandidateInfo info)
    {
        var docType = info.AggregateType!.ToDisplayString();
        var idType = info.IdentityType!.ToDisplayString();

        sb.AppendLine($"    public override {docType}? Evolve({docType}? snapshot, {idType} id, global::JasperFx.Events.IEvent e)");
        sb.AppendLine("    {");

        var createMethods = info.Methods.Where(m => m.MethodName == "Create").ToList();
        var applyMethods = info.Methods.Where(m => m.MethodName == "Apply").ToList();

        // Null snapshot branch
        sb.AppendLine("        if (snapshot == null)");
        sb.AppendLine("        {");
        sb.AppendLine("            switch (e.Data)");
        sb.AppendLine("            {");
        EmitNullSnapshotCases(sb, info, createMethods, applyMethods, "                ");
        sb.AppendLine("                default: return null;");
        sb.AppendLine("            }");
        sb.AppendLine("        }");
        sb.AppendLine();

        // Non-null snapshot branch
        sb.AppendLine("        switch (e.Data)");
        sb.AppendLine("        {");
        EmitNonNullSnapshotCases(sb, info, applyMethods, "            ");
        sb.AppendLine("            default: return snapshot;");
        sb.AppendLine("        }");

        sb.AppendLine("    }");
    }

    // --- Partial projection: EvolveAsync (mixed sync/async, no ShouldDelete) ---

    private static void EmitEvolveAsyncOverride(StringBuilder sb, CandidateInfo info)
    {
        var docType = info.AggregateType!.ToDisplayString();
        var idType = info.IdentityType!.ToDisplayString();
        var sessionType = info.QuerySessionType?.ToDisplayString() ?? "object";

        sb.AppendLine($"    public override async global::System.Threading.Tasks.ValueTask<{docType}?> EvolveAsync(");
        sb.AppendLine($"        {docType}? snapshot, {idType} id, {sessionType} session,");
        sb.AppendLine($"        global::JasperFx.Events.IEvent e, global::System.Threading.CancellationToken cancellation)");
        sb.AppendLine("    {");

        var createMethods = info.Methods.Where(m => m.MethodName == "Create").ToList();
        var applyMethods = info.Methods.Where(m => m.MethodName == "Apply").ToList();

        sb.AppendLine("        if (snapshot == null)");
        sb.AppendLine("        {");
        sb.AppendLine("            switch (e.Data)");
        sb.AppendLine("            {");
        EmitNullSnapshotCasesAsync(sb, info, createMethods, applyMethods, "                ");
        sb.AppendLine("                default: return null;");
        sb.AppendLine("            }");
        sb.AppendLine("        }");
        sb.AppendLine();

        sb.AppendLine("        switch (e.Data)");
        sb.AppendLine("        {");
        EmitNonNullSnapshotCasesAsync(sb, info, applyMethods, "            ");
        sb.AppendLine("            default: return snapshot;");
        sb.AppendLine("        }");

        sb.AppendLine("    }");
    }

    // --- Partial projection: DetermineActionAsync (has ShouldDelete) ---

    private static void EmitDetermineActionAsyncOverride(StringBuilder sb, CandidateInfo info)
    {
        var docType = info.AggregateType!.ToDisplayString();
        var idType = info.IdentityType!.ToDisplayString();
        var sessionType = info.QuerySessionType?.ToDisplayString() ?? "object";

        var isAsync = info.HasAnyAsync;
        var asyncKeyword = isAsync ? "async " : "";

        sb.AppendLine($"    public override {asyncKeyword}global::System.Threading.Tasks.ValueTask<({docType}?, global::JasperFx.Events.Daemon.ActionType)> DetermineActionAsync(");
        sb.AppendLine($"        {sessionType} session,");
        sb.AppendLine($"        {docType}? snapshot,");
        sb.AppendLine($"        {idType} identity,");
        sb.AppendLine($"        global::JasperFx.Events.Aggregation.IIdentitySetter<{docType}, {idType}> identitySetter,");
        sb.AppendLine($"        global::System.Collections.Generic.IReadOnlyList<global::JasperFx.Events.IEvent> events,");
        sb.AppendLine("        global::System.Threading.CancellationToken cancellation)");
        sb.AppendLine("    {");
        sb.AppendLine("        var exists = snapshot != null;");
        sb.AppendLine("        foreach (var e in events)");
        sb.AppendLine("        {");
        sb.AppendLine("            switch (e.Data)");
        sb.AppendLine("            {");

        // ShouldDelete cases first
        var shouldDeleteMethods = info.Methods.Where(m => m.MethodName == "ShouldDelete").ToList();
        foreach (var method in shouldDeleteMethods)
        {
            var eventTypeName = method.EventType.ToDisplayString();
            var dataVar = "data";
            sb.AppendLine($"                case {eventTypeName} {dataVar}:");
            sb.Append("                    if (snapshot != null && ");
            EmitShouldDeleteCall(sb, method, dataVar);
            sb.AppendLine(")");
            sb.AppendLine("                        snapshot = null;");
            sb.AppendLine("                    break;");
        }

        // Create cases
        var createMethods = info.Methods.Where(m => m.MethodName == "Create").ToList();
        foreach (var method in createMethods)
        {
            var eventTypeName = method.EventType.ToDisplayString();
            sb.AppendLine($"                case {eventTypeName} data when snapshot == null:");
            sb.Append("                    snapshot = ");
            EmitCreateCall(sb, method, "data", "e", isAsync);
            sb.AppendLine(";");
            sb.AppendLine("                    break;");
        }

        // Apply cases
        var applyMethods = info.Methods.Where(m => m.MethodName == "Apply").ToList();
        foreach (var method in applyMethods)
        {
            var eventTypeName = method.EventType.ToDisplayString();
            // For apply methods where there's no create, we need to handle null snapshot
            bool hasCreateForType = createMethods.Any(c =>
                SymbolEqualityComparer.Default.Equals(c.EventType, method.EventType));

            if (hasCreateForType)
            {
                // Apply only when snapshot exists
                sb.AppendLine($"                case {eventTypeName} data when snapshot != null:");
            }
            else if (info.HasDefaultConstructor)
            {
                sb.AppendLine($"                case {eventTypeName} data:");
                sb.AppendLine($"                    snapshot ??= new {info.AggregateType!.ToDisplayString()}();");
            }
            else
            {
                sb.AppendLine($"                case {eventTypeName} data when snapshot != null:");
            }

            sb.Append("                    ");
            EmitApplyCallStatement(sb, method, "data", "e", isAsync);
            sb.AppendLine("                    break;");
        }

        sb.AppendLine("            }");
        sb.AppendLine("        }");
        sb.AppendLine();
        sb.AppendLine("        if (snapshot == null)");
        sb.AppendLine($"            return exists ? (null, global::JasperFx.Events.Daemon.ActionType.Delete) : (null, global::JasperFx.Events.Daemon.ActionType.Nothing);");
        if (!isAsync)
        {
            sb.AppendLine($"        return new global::System.Threading.Tasks.ValueTask<({docType}?, global::JasperFx.Events.Daemon.ActionType)>((snapshot, global::JasperFx.Events.Daemon.ActionType.Store));");
        }
        else
        {
            sb.AppendLine($"        return (snapshot, global::JasperFx.Events.Daemon.ActionType.Store);");
        }
        sb.AppendLine("    }");
    }

    // --- Self-aggregating: Evolve (sync, no ShouldDelete) ---

    private static void EmitSelfAggregatingEvolve(StringBuilder sb, CandidateInfo info, string docType,
        string idType)
    {
        sb.AppendLine(
            $"    public {docType}? Evolve({docType}? snapshot, {idType} id, global::JasperFx.Events.IEvent e)");
        sb.AppendLine("    {");
        sb.AppendLine("        switch (e.Data)");
        sb.AppendLine("        {");

        var createMethods = info.Methods.Where(m => m.MethodName == "Create").ToList();
        var applyMethods = info.Methods.Where(m => m.MethodName == "Apply").ToList();

        // Each event type gets one case
        var allEventTypes = info.Methods.Select(m => m.EventType).Distinct(SymbolEqualityComparer.Default).ToList();

        foreach (var eventType in allEventTypes)
        {
            var eventTypeName = eventType!.ToDisplayString();
            var creates = createMethods.Where(m =>
                SymbolEqualityComparer.Default.Equals(m.EventType, eventType)).ToList();
            var applies = applyMethods.Where(m =>
                SymbolEqualityComparer.Default.Equals(m.EventType, eventType)).ToList();

            sb.AppendLine($"            case {eventTypeName} data:");

            if (creates.Count > 0)
            {
                var create = creates[0];
                sb.AppendLine("                if (snapshot == null)");
                sb.Append("                    snapshot = ");
                EmitSelfAggregatingCreateCall(sb, create, "data");
                sb.AppendLine(";");

                if (applies.Count > 0)
                {
                    sb.AppendLine("                else");
                    sb.Append("                    ");
                    EmitSelfAggregatingApplyCall(sb, applies[0], "data");
                }
            }
            else if (applies.Count > 0)
            {
                if (info.HasDefaultConstructor)
                {
                    sb.AppendLine($"                snapshot ??= new {docType}();");
                }
                else
                {
                    sb.AppendLine("                if (snapshot == null) return null;");
                }

                sb.Append("                ");
                EmitSelfAggregatingApplyCall(sb, applies[0], "data");
            }

            sb.AppendLine("                return snapshot;");
        }

        sb.AppendLine("            default:");
        sb.AppendLine("                return snapshot;");
        sb.AppendLine("        }");
        sb.AppendLine("    }");
    }

    // --- Self-aggregating: DetermineAction (sync, with ShouldDelete) ---

    private static void EmitSelfAggregatingDetermineAction(StringBuilder sb, CandidateInfo info, string docType,
        string idType)
    {
        sb.AppendLine(
            $"    public ({docType}?, global::JasperFx.Events.Daemon.ActionType) DetermineAction({docType}? snapshot, {idType} id, global::System.Collections.Generic.IReadOnlyList<global::JasperFx.Events.IEvent> events)");
        sb.AppendLine("    {");
        sb.AppendLine("        var exists = snapshot != null;");
        sb.AppendLine("        foreach (var e in events)");
        sb.AppendLine("        {");
        sb.AppendLine("            switch (e.Data)");
        sb.AppendLine("            {");

        // ShouldDelete - set snapshot to null and continue processing (allows re-creation)
        var shouldDeleteMethods = info.Methods.Where(m => m.MethodName == "ShouldDelete").ToList();
        foreach (var method in shouldDeleteMethods)
        {
            var eventTypeName = method.EventType.ToDisplayString();
            sb.AppendLine($"                case {eventTypeName} data:");
            sb.Append("                    if (snapshot != null && ");
            EmitSelfAggregatingShouldDeleteCall(sb, method, "data");
            sb.AppendLine(")");
            sb.AppendLine("                        snapshot = null;");
            sb.AppendLine("                    break;");
        }

        // Create + Apply
        var createMethods = info.Methods.Where(m => m.MethodName == "Create").ToList();
        var applyMethods = info.Methods.Where(m => m.MethodName == "Apply").ToList();

        // Group by event type (excluding ShouldDelete events already handled)
        var handledDeleteTypes = new HashSet<ITypeSymbol>(shouldDeleteMethods.Select(m => m.EventType),
            SymbolEqualityComparer.Default);

        var applyAndCreateTypes = info.Methods
            .Where(m => m.MethodName != "ShouldDelete")
            .Select(m => m.EventType)
            .Distinct(SymbolEqualityComparer.Default)
            .Where(t => !handledDeleteTypes.Contains(t!))
            .ToList();

        foreach (var eventType in applyAndCreateTypes)
        {
            var eventTypeName = eventType!.ToDisplayString();
            var creates = createMethods.Where(m =>
                SymbolEqualityComparer.Default.Equals(m.EventType, eventType)).ToList();
            var applies = applyMethods.Where(m =>
                SymbolEqualityComparer.Default.Equals(m.EventType, eventType)).ToList();

            sb.AppendLine($"                case {eventTypeName} data:");

            if (creates.Count > 0)
            {
                var create = creates[0];
                sb.AppendLine("                    if (snapshot == null)");
                sb.Append("                        snapshot = ");
                EmitSelfAggregatingCreateCall(sb, create, "data");
                sb.AppendLine(";");

                if (applies.Count > 0)
                {
                    sb.AppendLine("                    else");
                    sb.Append("                        ");
                    EmitSelfAggregatingApplyCall(sb, applies[0], "data");
                }
            }
            else if (applies.Count > 0)
            {
                if (info.HasDefaultConstructor)
                {
                    sb.AppendLine(
                        $"                    snapshot ??= new {info.AggregateType!.ToDisplayString()}();");
                }
                else
                {
                    sb.AppendLine("                    if (snapshot == null) break;");
                }

                sb.Append("                    ");
                EmitSelfAggregatingApplyCall(sb, applies[0], "data");
            }

            sb.AppendLine("                    break;");
        }

        sb.AppendLine("            }");
        sb.AppendLine("        }");
        sb.AppendLine();
        sb.AppendLine("        if (snapshot == null)");
        sb.AppendLine(
            "            return exists ? (null, global::JasperFx.Events.Daemon.ActionType.Delete) : (null, global::JasperFx.Events.Daemon.ActionType.Nothing);");
        sb.AppendLine($"        return (snapshot, global::JasperFx.Events.Daemon.ActionType.Store);");
        sb.AppendLine("    }");
    }

    // --- Null snapshot case generation (sync) ---

    private static void EmitNullSnapshotCases(StringBuilder sb, CandidateInfo info,
        List<ConventionalMethodInfo> createMethods, List<ConventionalMethodInfo> applyMethods, string indent)
    {
        // For each event type with a Create method
        foreach (var method in createMethods)
        {
            var eventTypeName = method.EventType.ToDisplayString();
            if (method.UsesIEventWrapper)
            {
                sb.AppendLine($"{indent}case {eventTypeName}:");
                sb.Append($"{indent}    return ");
                EmitCreateCallSync(sb, method, null, "e");
            }
            else
            {
                sb.AppendLine($"{indent}case {eventTypeName} data:");
                sb.Append($"{indent}    return ");
                EmitCreateCallSync(sb, method, "data", "e");
            }

            sb.AppendLine(";");
        }

        // For Apply-only event types (no matching Create), use default ctor + Apply
        var createEventTypes = new HashSet<ITypeSymbol>(createMethods.Select(m => m.EventType),
            SymbolEqualityComparer.Default);

        foreach (var method in applyMethods)
        {
            if (createEventTypes.Contains(method.EventType)) continue;

            var eventTypeName = method.EventType.ToDisplayString();
            var docType = info.AggregateType!.ToDisplayString();

            if (!info.HasDefaultConstructor) continue; // Can't create without constructor

            if (method.UsesIEventWrapper)
            {
                sb.AppendLine($"{indent}case {eventTypeName}:");
            }
            else
            {
                sb.AppendLine($"{indent}case {eventTypeName} data:");
            }

            if (method.IsVoid && !method.ReturnsAggregate)
            {
                sb.AppendLine($"{indent}{{");
                sb.AppendLine($"{indent}    var s = new {docType}();");
                sb.Append($"{indent}    ");
                EmitApplyCallExpression(sb, method, method.UsesIEventWrapper ? null : "data", "e", false, "s");
                sb.AppendLine(";");
                sb.AppendLine($"{indent}    return s;");
                sb.AppendLine($"{indent}}}");
            }
            else
            {
                // Returns aggregate - pass new instance
                sb.Append($"{indent}    return ");
                EmitApplyCallExpression(sb, method, method.UsesIEventWrapper ? null : "data", "e", false, $"new {docType}()");
                sb.AppendLine(";");
            }
        }
    }

    // --- Null snapshot case generation (async) ---

    private static void EmitNullSnapshotCasesAsync(StringBuilder sb, CandidateInfo info,
        List<ConventionalMethodInfo> createMethods, List<ConventionalMethodInfo> applyMethods, string indent)
    {
        foreach (var method in createMethods)
        {
            var eventTypeName = method.EventType.ToDisplayString();
            if (method.UsesIEventWrapper)
            {
                sb.AppendLine($"{indent}case {eventTypeName}:");
                sb.Append($"{indent}    return ");
            }
            else
            {
                sb.AppendLine($"{indent}case {eventTypeName} data:");
                sb.Append($"{indent}    return ");
            }

            EmitCreateCall(sb, method, method.UsesIEventWrapper ? null : "data", "e", true);
            sb.AppendLine(";");
        }

        var createEventTypes = new HashSet<ITypeSymbol>(createMethods.Select(m => m.EventType),
            SymbolEqualityComparer.Default);

        foreach (var method in applyMethods)
        {
            if (createEventTypes.Contains(method.EventType)) continue;
            if (!info.HasDefaultConstructor) continue;

            var eventTypeName = method.EventType.ToDisplayString();
            var docType = info.AggregateType!.ToDisplayString();

            sb.AppendLine($"{indent}case {eventTypeName} data:");
            sb.AppendLine($"{indent}{{");
            sb.AppendLine($"{indent}    var s = new {docType}();");
            var awaitPrefix = method.IsAsync ? "await " : "";
            sb.Append($"{indent}    {awaitPrefix}");
            EmitApplyCallExpression(sb, method, "data", "e", true, "s");
            sb.AppendLine(";");
            sb.AppendLine($"{indent}    return s;");
            sb.AppendLine($"{indent}}}");
        }
    }

    // --- Non-null snapshot case generation (sync) ---

    private static void EmitNonNullSnapshotCases(StringBuilder sb, CandidateInfo info,
        List<ConventionalMethodInfo> applyMethods, string indent)
    {
        foreach (var method in applyMethods)
        {
            var eventTypeName = method.EventType.ToDisplayString();

            if (method.UsesIEventWrapper)
            {
                sb.AppendLine($"{indent}case {eventTypeName}:");
            }
            else
            {
                sb.AppendLine($"{indent}case {eventTypeName} data:");
            }

            if (method.IsVoid && !method.ReturnsAggregate)
            {
                sb.Append($"{indent}    ");
                EmitApplyCallExpression(sb, method, method.UsesIEventWrapper ? null : "data", "e", false);
                sb.AppendLine(";");
                sb.AppendLine($"{indent}    return snapshot;");
            }
            else
            {
                sb.Append($"{indent}    return ");
                EmitApplyCallExpression(sb, method, method.UsesIEventWrapper ? null : "data", "e", false);
                sb.AppendLine(";");
            }
        }
    }

    // --- Non-null snapshot case generation (async) ---

    private static void EmitNonNullSnapshotCasesAsync(StringBuilder sb, CandidateInfo info,
        List<ConventionalMethodInfo> applyMethods, string indent)
    {
        foreach (var method in applyMethods)
        {
            var eventTypeName = method.EventType.ToDisplayString();
            sb.AppendLine($"{indent}case {eventTypeName} data:");

            if (method.IsAsync)
            {
                if (method.ReturnsAggregate)
                {
                    sb.Append($"{indent}    return await ");
                    EmitApplyCallExpression(sb, method, "data", "e", true);
                    sb.AppendLine(";");
                }
                else
                {
                    sb.Append($"{indent}    await ");
                    EmitApplyCallExpression(sb, method, "data", "e", true);
                    sb.AppendLine(";");
                    sb.AppendLine($"{indent}    return snapshot;");
                }
            }
            else
            {
                if (method.ReturnsAggregate)
                {
                    sb.Append($"{indent}    return ");
                    EmitApplyCallExpression(sb, method, "data", "e", false);
                    sb.AppendLine(";");
                }
                else
                {
                    sb.Append($"{indent}    ");
                    EmitApplyCallExpression(sb, method, "data", "e", false);
                    sb.AppendLine(";");
                    sb.AppendLine($"{indent}    return snapshot;");
                }
            }
        }
    }

    // --- Call expression helpers ---

    private static void EmitApplyCallExpression(StringBuilder sb, ConventionalMethodInfo method,
        string? dataVar, string eventVar, bool includeSessionAndCancellation, string aggregateVar = "snapshot")
    {
        var args = BuildApplyArgs(method, dataVar, eventVar, includeSessionAndCancellation, aggregateVar);

        if (method.IsOnAggregate)
        {
            sb.Append($"{aggregateVar}.{method.MethodName}({args})");
        }
        else
        {
            sb.Append($"{method.MethodName}({args})");
        }
    }

    private static void EmitCreateCallSync(StringBuilder sb, ConventionalMethodInfo method,
        string? dataVar, string eventVar)
    {
        var args = BuildCreateArgs(method, dataVar, eventVar, false);

        if (method.IsStatic)
        {
            var containingType = method.Symbol.ContainingType.ToDisplayString();
            sb.Append($"{containingType}.{method.MethodName}({args})");
        }
        else if (method.IsOnAggregate)
        {
            // Static create on aggregate
            var containingType = method.Symbol.ContainingType.ToDisplayString();
            sb.Append($"{containingType}.{method.MethodName}({args})");
        }
        else
        {
            sb.Append($"{method.MethodName}({args})");
        }
    }

    private static void EmitCreateCall(StringBuilder sb, ConventionalMethodInfo method,
        string? dataVar, string eventVar, bool isAsync)
    {
        var args = BuildCreateArgs(method, dataVar, eventVar, isAsync);
        var awaitPrefix = method.IsAsync && isAsync ? "await " : "";

        if (method.IsStatic)
        {
            var containingType = method.Symbol.ContainingType.ToDisplayString();
            sb.Append($"{awaitPrefix}{containingType}.{method.MethodName}({args})");
        }
        else if (method.IsOnAggregate)
        {
            var containingType = method.Symbol.ContainingType.ToDisplayString();
            sb.Append($"{awaitPrefix}{containingType}.{method.MethodName}({args})");
        }
        else
        {
            sb.Append($"{awaitPrefix}{method.MethodName}({args})");
        }
    }

    private static void EmitApplyCallStatement(StringBuilder sb, ConventionalMethodInfo method,
        string dataVar, string eventVar, bool isAsync)
    {
        if (method.IsAsync && isAsync)
        {
            if (method.ReturnsAggregate)
            {
                sb.Append("snapshot = await ");
            }
            else
            {
                sb.Append("await ");
            }
        }
        else
        {
            if (method.ReturnsAggregate)
            {
                sb.Append("snapshot = ");
            }
        }

        EmitApplyCallExpression(sb, method, dataVar, eventVar, isAsync);
        sb.AppendLine(";");
    }

    private static void EmitShouldDeleteCall(StringBuilder sb, ConventionalMethodInfo method, string dataVar)
    {
        var args = BuildShouldDeleteArgs(method, dataVar);

        if (method.IsOnAggregate)
        {
            sb.Append($"snapshot.{method.MethodName}({args})");
        }
        else
        {
            sb.Append($"{method.MethodName}({args})");
        }
    }

    private static string BuildSelfAggregatingArgs(ConventionalMethodInfo method, string dataVar)
    {
        var parts = new List<string>();
        var parameters = method.Symbol.Parameters;

        foreach (var param in parameters)
        {
            var paramType = param.Type;

            if (method.UsesIEventWrapper && IsIEventGenericWrapper(paramType))
            {
                var innerType = ((INamedTypeSymbol)paramType).TypeArguments[0].ToDisplayString();
                parts.Add($"(global::JasperFx.Events.IEvent<{innerType}>)e");
            }
            else if (IsRawIEvent(paramType))
            {
                parts.Add("e");
            }
            else
            {
                // Event data
                parts.Add(dataVar);
            }
        }

        return string.Join(", ", parts);
    }

    private static void EmitSelfAggregatingCreateCall(StringBuilder sb, ConventionalMethodInfo method,
        string dataVar)
    {
        var args = BuildSelfAggregatingArgs(method, dataVar);

        if (method.IsStatic)
        {
            var containingType = method.Symbol.ContainingType.ToDisplayString();
            sb.Append($"{containingType}.{method.MethodName}({args})");
        }
        else
        {
            // Instance Create on aggregate - not typical for self-aggregating
            sb.Append($"snapshot.{method.MethodName}({args})");
        }
    }

    private static void EmitSelfAggregatingApplyCall(StringBuilder sb, ConventionalMethodInfo method,
        string dataVar)
    {
        var args = BuildSelfAggregatingArgs(method, dataVar);

        // Self-aggregating: method is on the aggregate instance
        if (method.ReturnsAggregate)
        {
            sb.AppendLine($"snapshot = snapshot.{method.MethodName}({args});");
        }
        else
        {
            sb.AppendLine($"snapshot.{method.MethodName}({args});");
        }
    }

    private static void EmitSelfAggregatingShouldDeleteCall(StringBuilder sb, ConventionalMethodInfo method,
        string dataVar)
    {
        var args = BuildSelfAggregatingArgs(method, dataVar);
        sb.Append($"snapshot.{method.MethodName}({args})");
    }

    // --- Argument builders ---

    private static string BuildApplyArgs(ConventionalMethodInfo method, string? dataVar, string eventVar,
        bool includeSessionAndCancellation, string aggregateVar = "snapshot")
    {
        var parts = new List<string>();
        var parameters = method.Symbol.Parameters;

        foreach (var param in parameters)
        {
            var paramType = param.Type;

            if (method.UsesIEventWrapper && IsIEventGenericWrapper(paramType))
            {
                var innerType = ((INamedTypeSymbol)paramType).TypeArguments[0].ToDisplayString();
                parts.Add($"(global::JasperFx.Events.IEvent<{innerType}>){eventVar}");
            }
            else if (IsRawIEvent(paramType))
            {
                parts.Add(eventVar);
            }
            else if (IsQuerySession(paramType) && includeSessionAndCancellation)
            {
                parts.Add("session");
            }
            else if (IsCancellationToken(paramType) && includeSessionAndCancellation)
            {
                parts.Add("cancellation");
            }
            else if (IsAggregateParam(paramType, method))
            {
                parts.Add(aggregateVar);
            }
            else
            {
                // Event data
                parts.Add(dataVar ?? $"(({paramType.ToDisplayString()})e.Data)");
            }
        }

        return string.Join(", ", parts);
    }

    private static string BuildCreateArgs(ConventionalMethodInfo method, string? dataVar, string eventVar,
        bool includeSessionAndCancellation)
    {
        var parts = new List<string>();
        var parameters = method.Symbol.Parameters;

        foreach (var param in parameters)
        {
            var paramType = param.Type;

            if (method.UsesIEventWrapper && IsIEventGenericWrapper(paramType))
            {
                var innerType = ((INamedTypeSymbol)paramType).TypeArguments[0].ToDisplayString();
                parts.Add($"(global::JasperFx.Events.IEvent<{innerType}>){eventVar}");
            }
            else if (IsRawIEvent(paramType))
            {
                parts.Add(eventVar);
            }
            else if (IsQuerySession(paramType) && includeSessionAndCancellation)
            {
                parts.Add("session");
            }
            else if (IsCancellationToken(paramType) && includeSessionAndCancellation)
            {
                parts.Add("cancellation");
            }
            else
            {
                // Event data
                parts.Add(dataVar ?? $"(({paramType.ToDisplayString()})e.Data)");
            }
        }

        return string.Join(", ", parts);
    }

    private static string BuildShouldDeleteArgs(ConventionalMethodInfo method, string dataVar)
    {
        var parts = new List<string>();
        var parameters = method.Symbol.Parameters;

        foreach (var param in parameters)
        {
            var paramType = param.Type;

            if (IsAggregateParam(paramType, method))
            {
                parts.Add("snapshot");
            }
            else if (method.UsesIEventWrapper && IsIEventGenericWrapper(paramType))
            {
                var innerType = ((INamedTypeSymbol)paramType).TypeArguments[0].ToDisplayString();
                parts.Add($"(global::JasperFx.Events.IEvent<{innerType}>)e");
            }
            else if (IsRawIEvent(paramType))
            {
                parts.Add("e");
            }
            else
            {
                parts.Add(dataVar);
            }
        }

        return string.Join(", ", parts);
    }

    private static bool IsAggregateParam(ITypeSymbol paramType, ConventionalMethodInfo method)
    {
        // For projection methods, the aggregate is a parameter
        if (!method.IsOnAggregate)
        {
            // Check if this parameter type matches the aggregate type from the method's context
            // We check by looking at whether the type isn't the event type, IEvent, session, or cancellation token
            return !SymbolEqualityComparer.Default.Equals(paramType, method.EventType)
                   && !IsIEventGenericWrapper(paramType)
                   && !IsRawIEvent(paramType)
                   && !IsQuerySession(paramType)
                   && !IsCancellationToken(paramType)
                   && !IsEventDataType(paramType, method);
        }

        return false;
    }

    private static bool IsEventDataType(ITypeSymbol paramType, ConventionalMethodInfo method)
    {
        return SymbolEqualityComparer.Default.Equals(paramType, method.EventType);
    }

    private static bool IsIEventGenericWrapper(ITypeSymbol type)
    {
        if (type is INamedTypeSymbol named && named.IsGenericType)
        {
            var constructedFrom = named.ConstructedFrom.ToDisplayString();
            return constructedFrom == "JasperFx.Events.IEvent<T>";
        }

        return false;
    }

    private static bool IsRawIEvent(ITypeSymbol type)
    {
        return type.ToDisplayString() == "JasperFx.Events.IEvent";
    }

    private static bool IsQuerySession(ITypeSymbol type)
    {
        var name = type.ToDisplayString();
        return name.EndsWith("IQuerySession") || name.EndsWith("QuerySession");
    }

    private static bool IsCancellationToken(ITypeSymbol type)
    {
        return type.ToDisplayString() == "System.Threading.CancellationToken";
    }
}
